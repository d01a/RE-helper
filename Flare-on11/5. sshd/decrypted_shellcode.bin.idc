//
// +-------------------------------------------------------------------------+
// |      This file was generated by The Interactive Disassembler (IDA)      |
// |           Copyright (c) 2024 Hex-Rays, <support@hex-rays.com>           |
// |                            Freeware version                             |
// +-------------------------------------------------------------------------+
//
//
//      This file should be used in the following way:
//         - reload executable into IDA with using switch -c
//         - use File, Load IDC file and load this file.
//
//      NOTE: This file doesn't contain all information from the database.
//

#define UNLOADED_FILE   1
#include <idc.idc>

static main(void)
{
        // set 'loading idc file' mode
        set_inf_attr(INF_GENFLAGS, INFFL_LOADIDC|get_inf_attr(INF_GENFLAGS));
        GenInfo();            // various settings
        Segments();           // segmentation
        LocalTypes();         // local types
        Patches();            // manual patches
        SegRegs();            // segment register values
        Bytes();              // individual bytes (code,data)
        Functions();          // function definitions
        // clear 'loading idc file' mode
        set_inf_attr(INF_GENFLAGS, ~INFFL_LOADIDC&get_inf_attr(INF_GENFLAGS));
}

//------------------------------------------------------------------------
// General information

static GenInfo(void) {

        delete_all_segments();    // purge database
	set_processor_type("metapc", SETPROC_USER);
	set_inf_attr(INF_COMPILER, 1);
	set_inf_attr(INF_STRLIT_BREAK, 0xA);
	set_flag(INF_CMTFLG, SCF_ALLCMT, 0);
	set_flag(INF_OUTFLAGS, OFLG_SHOW_VOID, 0);
	set_inf_attr(INF_XREFNUM, 0);
	set_flag(INF_OUTFLAGS, OFLG_SHOW_AUTO, 1);
	set_inf_attr(INF_INDENT, 0);
	set_inf_attr(INF_CMT_INDENT, 24);
	set_inf_attr(INF_MAXREF, 0x10);
	add_default_til("gnulnx_x64");
}

//------------------------------------------------------------------------
// Information about segmentation

static Segments(void) {
	set_selector(0X1,0);

	add_segm_ex(0,0XF98,0X1,2,1,2,ADDSEG_NOSREG);
	SegRename(0,"seg000");
	SegClass (0,"CODE");
	SegDefReg(0x0,"es",0x0);
	SegDefReg(0x0,"ss",0x0);
	SegDefReg(0x0,"ds",0x0);
	SegDefReg(0x0,"fs",0x0);
	SegDefReg(0x0,"gs",0x0);
	set_segm_type(0,2);
	set_inf_attr(INF_LOW_OFF, 0xFFFFFFFFFFFFFFFF);
	set_inf_attr(INF_HIGH_OFF, 0xF98);
}

static LocalTypes_0() 
{
        auto p_type, p_fields, p_cmt, p_fldcmts;

	p_type = "\x0A\x0A\x01";
	set_named_type("va_list", NTF_REPLACE, p_type, "", "", "");
	p_type = "-\x0A\x80AAAAAAD\xBF\xFFv\x9F\xFF\xC0\xA0@";
	p_fields = "\x0CSOCK_STREAM\x0BSOCK_DGRAM\x09SOCK_RAW\x09SOCK_RDM\x0FSOCK_SEQPACKE"
	  "T\x0ASOCK_DCCP\x0CSOCK_PACKET\x0DSOCK_CLOEXEC\x0ESOCK_NONBLOCK";
	set_named_type("__socket_type", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "-+\xC0@A@@AAAAAAAAAAAAAAA@AAAAAAAAAACAAAAAAAAAAA";
	p_fields = "\x0AAF_UNSPEC\x09AF_LOCAL\x08AF_UNIX\x08AF_FILE\x08AF_INET\x08AF_AX25\x07"
	  "AF_IPX\x0DAF_APPLETALK\x0AAF_NETROM\x0AAF_BRIDGE\x0AAF_ATMPVC\x07AF_X2"
	  "5\x09AF_INET6\x08AF_ROSE\x0AAF_DECnet\x0BAF_NETBEUI\x0CAF_SECURITY\x07"
	  "AF_KEY\x0BAF_NETLINK\x09AF_ROUTE\x0AAF_PACKET\x07AF_ASH\x0AAF_ECONET\x0A"
	  "AF_ATMSVC\x07AF_RDS\x07AF_SNA\x08AF_IRDA\x09AF_PPPOX\x0BAF_WANPIPE\x07"
	  "AF_LLC\x07AF_CAN\x08AF_TIPC\x0DAF_BLUETOOTH\x08AF_IUCV\x09AF_RXRPC\x08"
	  "AF_ISDN\x0AAF_PHONET\x0EAF_IEEE802154\x08AF_CAIF\x07AF_ALG\x07AF_NFC\x07"
	  "AF_MAX";
	set_named_type("MACRO_AF", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "-\x0F\xC0AAAAAAAAAAAAAA";
	p_fields = "\x0CTCP_NODELAY\x0BTCP_MAXSEG\x09TCP_CORK\x0DTCP_KEEPIDLE\x0ETCP_KEEPI"
	  "NTVL\x0CTCP_KEEPCNT\x0BTCP_SYNCNT\x0CTCP_LINGER2\x11TCP_DEFER_ACCEPT\x11"
	  "TCP_WINDOW_CLAMP\x09TCP_INFO\x0DTCP_QUICKACK\x0FTCP_CONGESTION\x0BTCP_"
	  "MD5SIG";
	set_named_type("MACRO_TCP", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x1DI\xD1%\x1B\x03\x09\x1B\x09\x02\x1B\x05\x03\x1B\x03\x04\x05\x1B\x09"
	  "\"\x1B\x05#\x1B\x03$";
	p_fields = "\x08m64_u64\x08m64_f32\x07m64_i8\x08m64_i16\x08m64_i32\x08m64_i64\x07m"
	  "64_u8\x08m64_u16\x08m64_u32";
	set_named_type("__m64", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x1DI\xE0\x1B\x05\x09\x1B\x03%\x1B\x11\x02\x1B\x09\x03\x1B\x05\x04\x1B"
	  "\x03\x05\x1B\x11\"\x1B\x09#\x1B\x05$";
	p_fields = "\x09m128_f32\x09m128_u64\x08m128_i8\x09m128_i16\x09m128_i32\x09m128_i6"
	  "4\x08m128_u8\x09m128_u16\x09m128_u32";
	set_named_type("__m128", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x0D\x09\x1B\x03\x19";
	p_fields = "\x0Am128d_f64";
	set_named_type("__m128d", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x1DA\xE0\x1B\x11\x02\x1B\x09\x03\x1B\x05\x04\x1B\x03\x05\x1B\x11\"\x1B"
	  "\x09#\x1B\x05$\x1B\x03%";
	p_fields = "\x09m128i_i8\x0Am128i_i16\x0Am128i_i32\x0Am128i_i64\x09m128i_u8\x0Am12"
	  "8i_u16\x0Am128i_u32\x0Am128i_u64";
	set_named_type("__m128i", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x1D\x09\xE1\x1B\x09\x09";
	p_fields = "\x09m256_f32";
	set_named_type("__m256", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x1D\x09\xE1\x1B\x05\x19";
	p_fields = "\x0Am256d_f64";
	set_named_type("__m256d", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x1DA\xE1\x1B!\x02\x1B\x11\x03\x1B\x09\x04\x1B\x05\x05\x1B!\"\x1B\x11#"
	  "\x1B\x09$\x1B\x05%";
	p_fields = "\x09m256i_i8\x0Am256i_i16\x0Am256i_i32\x0Am256i_i64\x09m256i_u8\x0Am25"
	  "6i_u16\x0Am256i_u32\x0Am256i_u64";
	set_named_type("__m256i", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x1D\x09\xF0\x1B\x11\x09";
	p_fields = "\x09m512_f32";
	set_named_type("__m512", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x1D\x09\xF0\x1B\x09\x19";
	p_fields = "\x0Am512d_f64";
	set_named_type("__m512d", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x1DA\xF0\x1BA\x02\x1B!\x03\x1B\x11\x04\x1B\x09\x05\x1BA\"\x1B!#\x1B\x11"
	  "$\x1B\x09%";
	p_fields = "\x09m512i_i8\x0Am512i_i16\x0Am512i_i32\x0Am512i_i64\x09m512i_u8\x0Am51"
	  "2i_u16\x0Am512i_u32\x0Am512i_u64";
	set_named_type("__m512i", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "\x0D!=\x0Csa_family_t=\x0Ain_port_t\x0D\x01\x08in_addr\x1B\x09\"";
	p_fields = "\x0Bsin_family\x09sin_port\x09sin_addr\x09sin_zero";
	set_named_type("sockaddr_in", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "#";
	set_named_type("sa_family_t", NTF_REPLACE, p_type, "", "", "");
	p_type = "=\x09uint16_t";
	set_named_type("in_port_t", NTF_REPLACE, p_type, "", "", "");
	p_type = "#";
	set_named_type("uint16_t", NTF_REPLACE, p_type, "", "", "");
	p_type = "\x0D\x09=\x0Ain_addr_t";
	p_fields = "\x07s_addr";
	set_named_type("in_addr", NTF_REPLACE, p_type, p_fields, "", "");
	p_type = "=\x09uint32_t";
	set_named_type("in_addr_t", NTF_REPLACE, p_type, "", "", "");
	p_type = "'";
	set_named_type("uint32_t", NTF_REPLACE, p_type, "", "", "");
	p_type = "\x0D\x11=\x0Csa_family_t\x1B\x0F2";
	p_fields = "\x0Asa_family\x08sa_data";
	set_named_type("sockaddr", NTF_REPLACE, p_type, p_fields, "", "");
}

//------------------------------------------------------------------------
// Information about local types

static LocalTypes()
{
	LocalTypes_0();
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_0(void) {
        auto x;
#define id x

	update_extra_cmt		(0,	E_PREV + 0,	"; File Name   : C:\\Users\\user\\Desktop\\shellcode.bin");
	update_extra_cmt		(0,	E_PREV + 1,	"; Format      : Binary file");
	update_extra_cmt		(0,	E_PREV + 2,	"; Base Address: 0000h Range: 0000h - 0F98h Loaded length: 0F98h");
	create_insn	(0);
	create_insn	(0XB);
	set_name	(0XB,	"close_file");
	set_cmt	(0X15,	"Low latency system call",	0);
	create_insn	(0X1A);
	set_name	(0X1A,	"connect_to_15.2.0.10:14597");
	create_insn	(x=0X2C);
	op_dec		(x,	0);
	set_cmt	(0X38,	"Low latency system call",	0);
	create_insn	(0X45);
	create_insn	(x=0X4C);
	op_stkvar	(x,	1);
	create_insn	(x=0X57);
	op_stkvar	(x,	0);
	create_insn	(x=0X5D);
	op_hex		(x,	1);
	set_cmt	(0X62,	"57",	0);
	create_insn	(x=0X62);
	op_stkvar	(x,	0);
	create_insn	(x=0X6A);
	op_stkvar	(x,	0);
	create_insn	(x=0X6E);
	op_stkvar	(x,	1);
	create_insn	(x=0X72);
	op_dec		(x,	0);
	set_cmt	(0X7B,	"Low latency system call",	0);
	create_insn	(0X84);
	create_insn	(0X88);
	create_insn	(0X8F);
	set_cmt	(0X9C,	"Low latency system call",	0);
	create_insn	(0XA2);
	create_insn	(0XB5);
	create_insn	(0XDA);
	create_insn	(0XE6);
	create_insn	(0XA2E);
	create_insn	(0XA37);
	create_insn	(0XA6C);
	create_insn	(0XA85);
	create_insn	(0XA93);
	set_name	(0XA93,	"prob_salsa20_or_chacha20_init");
	create_insn	(x=0XACB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAE9,	"a1",	0);
	set_cmt	(0XB08,	"a1",	0);
	set_cmt	(0XB27,	"a1",	0);
	set_cmt	(0XB47,	"a1",	0);
	set_cmt	(0XB65,	"a1",	0);
	set_cmt	(0XB84,	"a1",	0);
	set_cmt	(0XBA3,	"a1",	0);
	set_cmt	(0XBC2,	"a1",	0);
	set_cmt	(0XBE1,	"a1",	0);
	set_cmt	(0XC00,	"a1",	0);
	set_cmt	(0XC1F,	"a1",	0);
	set_cmt	(0XC3F,	"a1",	0);
	set_cmt	(0XC71,	"a1",	0);
	set_cmt	(0XC90,	"a1",	0);
	set_cmt	(0XCAF,	"a1",	0);
	create_insn	(0XCD2);
	set_name	(0XCD2,	"prob_chacha20_init");
	set_cmt	(0XCF0,	"context",	0);
	set_cmt	(0XCF3,	"nonce",	0);
	set_cmt	(0XD24,	"a1",	0);
	create_insn	(x=0XD30);
	op_hex		(x,	1);
	create_insn	(0XD49);
	set_name	(0XD49,	"decrypt");
	create_insn	(0XD6F);
	create_insn	(0XD7B);
	create_insn	(0XD84);
	create_insn	(0XDC2);
	set_name	(0XDC2,	"sc_main");
	set_cmt	(0XDD3,	"__int32",	0);
	set_cmt	(0XDD8,	"__int16",	0);
	create_insn	(x=0XDD8);
	op_dec		(x,	1);
	create_insn	(x=0XDE3);
	op_stkvar	(x,	1);
	set_cmt	(0XDEA,	"__int64 __usercall recvfrom@<rax>(int sockfd@<rdi>, void buf* @<rsi>, __int64 len@<rdx>,\nint flags@<r10>,  struct sockaddr src_addr@<r8>,\n socklen_t addrlen@<r9>);",	1);
	create_insn	(x=0XDEA);
	op_dec		(x,	0);
	set_cmt	(0XDED,	"sock connection stat",	0);
	set_cmt	(0XDF1,	"len = 32",	1);
	set_cmt	(0XDFB,	"recvfrom; Low latency system call",	0);
	create_insn	(x=0XDFD);
	op_stkvar	(x,	1);
	create_insn	(x=0XE04);
	op_dec		(x,	0);
	set_cmt	(0XE15,	"Low latency system call",	0);
	create_insn	(x=0XE17);
	op_stkvar	(x,	1);
	set_cmt	(0XE2F,	"Low latency system call",	0);
	create_insn	(x=0XE31);
	op_stkvar	(x,	1);
	create_insn	(x=0XE38);
	op_dec		(x,	0);
	create_insn	(x=0XE3D);
	op_stkvar	(x,	1);
	set_cmt	(0XE4C,	"Low latency system call",	0);
	create_insn	(x=0XE51);
	op_stkvar	(x,	0);
	create_insn	(x=0XE59);
	op_stkvar	(x,	1);
	set_cmt	(0XE67,	"Low latency system call",	0);
	create_insn	(x=0XE6C);
	op_stkvar	(x,	1);
	set_cmt	(0XE7D,	"Low latency system call",	0);
	create_insn	(x=0XE7F);
	op_stkvar	(x,	1);
	create_insn	(x=0XE93);
	op_stkvar	(x,	0);
	set_cmt	(0XE99,	"crypto_context",	0);
	create_insn	(x=0XE99);
	op_stkvar	(x,	1);
	set_cmt	(0XEA0,	"prob_key",	0);
	create_insn	(x=0XEA0);
	op_stkvar	(x,	1);
	set_cmt	(0XEA7,	"prob_nonce",	0);
	create_insn	(x=0XEA7);
	op_stkvar	(x,	1);
	set_cmt	(0XEAE,	"prob_counter",	0);
	set_cmt	(0XEB6,	"_BYTE *",	0);
	create_insn	(x=0XEB6);
	op_stkvar	(x,	1);
	set_cmt	(0XEBD,	"_BYTE *",	0);
	create_insn	(x=0XEBD);
	op_stkvar	(x,	1);
	set_cmt	(0XEC4,	"file_content_len",	0);
	create_insn	(x=0XEC4);
	op_stkvar	(x,	1);
	create_insn	(x=0XECF);
	op_stkvar	(x,	1);
	create_insn	(x=0XED6);
	op_dec		(x,	0);
	set_cmt	(0XEE7,	"Low latency system call",	0);
	create_insn	(x=0XEE9);
	op_stkvar	(x,	1);
	create_insn	(x=0XEF0);
	op_dec		(x,	0);
	create_insn	(x=0XEF5);
	op_stkvar	(x,	1);
	set_cmt	(0XF04,	"Low latency system call",	0);
	set_cmt	(0XF06,	"_DWORD",	0);
	set_cmt	(0XF0E,	"_DWORD",	0);
	set_cmt	(0XF10,	"_DWORD",	0);
	create_insn	(0XF20);
	create_insn	(x=0XF2F);
	op_hex		(x,	1);
	create_insn	(x=0XF44);
	op_hex		(x,	1);
	create_insn	(x=0XF55);
	op_hex		(x,	1);
	create_insn	(x=0XF63);
	op_hex		(x,	1);
	create_insn	(0XF6A);
	create_strlit	(0XF85,	0X11);
	set_name	(0XF85,	"aExpand32ByteK");
	set_cmt	(0XF96,	"DMA 8237A-5. mode register bits:\n0-1: channel (00=0; 01=1; 10=2; 11=3)\n2-3: transfer type (00=verify=Nop; 01=write; 10=read)\n4: 1=enable auto-initialization\n5: 1=address increment; 0=address decrement\n6-7: 00=demand mode; 01=single; 10=block; 11=cascade",	0);
	create_insn	(x=0XF96);
	op_hex		(x,	0);
}

static Functions_0(void) {

	add_func    (0XB,0X1A);
	set_func_flags(0XB,0x5410);
	SetType(0XB, "__int64 __usercall close_file@<rax>(_DWORD@<eax>);");
	set_frame_size(0XB, 0, 16, 0);
	add_func    (0X1A,0X8F);
	set_func_flags(0X1A,0x5410);
	SetType(0X1A, "int __userpurge connect_to_15_2_0_10_14597@<eax>(__int32@<eax>, __int16@<dx>);");
	set_frame_size(0X1A, 0X10, 24, 0);
	define_local_var(0X1A, 0X8F, "[bp-0X10]", "addr");
	add_func    (0X8F,0XA2);
	set_func_flags(0X8F,0x5410);
	SetType(0X8F, "__int64 __usercall sub_8F@<rax>(_DWORD@<eax>, _DWORD@<edx>);");
	set_frame_size(0X8F, 0, 24, 0);
	add_func    (0XA2,0XA93);
	set_func_flags(0XA2,0x5410);
	SetType(0XA2, "__int64 __fastcall sub_A2();");
	set_frame_size(0XA2, 0, 32, 0);
	add_func    (0XA93,0XCD2);
	set_func_flags(0XA93,0x5410);
	SetType(0XA93, "_DWORD *__usercall prob_salsa20_or_chacha20_init@<rax>(_BYTE *context@<rax>, _BYTE *key@<rdx>, _BYTE *nonce@<rcx>);");
	set_frame_size(0XA93, 0, 48, 0);
	add_func    (0XCD2,0XD49);
	set_func_flags(0XCD2,0x5410);
	SetType(0XCD2, "__int64 __usercall prob_chacha20_init@<rax>(_BYTE *crypto_context@<rax>, _BYTE *prob_key@<rdx>, _BYTE *prob_nonce@<rcx>, __int64 prob_counter@<r8>);");
	set_frame_size(0XCD2, 0, 40, 0);
	add_func    (0XD49,0XDC2);
	set_func_flags(0XD49,0x5410);
	SetType(0XD49, "__int64 __usercall decrypt@<rax>(_BYTE *@<rax>, _BYTE *@<rdx>, int file_content_len@<ecx>);");
	set_frame_size(0XD49, 0, 48, 0);
	add_func    (0XDC2,0XF20);
	set_func_flags(0XDC2,0x5410);
	SetType(0XDC2, "size_t __userpurge sc_main@<rax>(int sockfd@<edi>, void *buf@<rsi>, size_t len@<rdx>, int flags@<r10d>, struct sockaddr *dest_addr@<r8>, socklen_t addrlen@<r9d>);");
	set_frame_size(0XDC2, 0X1688, 40, 0);
	define_local_var(0XDC2, 0XF20, "[bp-0X1278]", "prob_key");
	define_local_var(0XDC2, 0XF20, "[bp-0X1258]", "prob_nonce");
	define_local_var(0XDC2, 0XF20, "[bp-0X1248]", "target_file_name");
	define_local_var(0XDC2, 0XF20, "[bp-0X1148]", "file_content");
	define_local_var(0XDC2, 0XF20, "[bp-0XC8]", "target_file_len");
	define_local_var(0XDC2, 0XF20, "[bp-0XC4]", "file_content_len");
	define_local_var(0XDC2, 0XF20, "[bp-0XC0]", "crypto_context");
	add_func    (0XF20,0XF6A);
	set_func_flags(0XF20,0x5410);
	SetType(0XF20, "unsigned int __usercall sub_F20@<eax>(_BYTE *a1@<rax>);");
	set_frame_size(0XF20, 0, 8, 0);
	add_func    (0XF6A,0XF85);
	set_func_flags(0XF6A,0x5410);
	SetType(0XF6A, "__int64 __fastcall sub_F6A(_QWORD, _QWORD);");
	set_frame_size(0XF6A, 0, 8, 0);
}

//------------------------------------------------------------------------
// Information about functions

static Functions(void) {

	Functions_0();
}

//------------------------------------------------------------------------
// Information about segment registers

static SegRegs(void) {
	split_sreg_range(0,"es",0,3);
	split_sreg_range(0,"ss",0,3);
	split_sreg_range(0,"ds",0,3);
	split_sreg_range(0,"fs",0,3);
	split_sreg_range(0,"gs",0,3);
}

//------------------------------------------------------------------------
// Information about all patched bytes:

static Patches(void) {
}

//------------------------------------------------------------------------
// Call all byte feature functions:

static Bytes(void) {
	Bytes_0();
}

// End of file.
